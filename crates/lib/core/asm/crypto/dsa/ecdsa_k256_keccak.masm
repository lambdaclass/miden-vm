use miden::core::crypto::hashes::keccak256
use miden::core::crypto::hashes::poseidon2
use miden::core::sys
use miden::core::word

# ENCODING CONVENTIONS
# ================================================================================================
#
# This module uses the following notation for data representation:
# - Byte arrays are stored in memory as packed u32 values in little-endian format
# - Each u32 represents 4 bytes: u32 = u32::from_le_bytes([b0, b1, b2, b3])
# - Unused bytes in the final u32 must be set to zero
# - Memory addresses must be word-aligned (divisible by 4)

# CONSTANTS
# ================================================================================================

const ECDSA_VERIFY_EVENT = event("miden::core::crypto::dsa::ecdsa_k256_keccak::verify")

const PK_LEN_FELTS = 9     # 33.div_ceil(4)
const DIGEST_LEN_FELTS = 8 # 32.div_ceil(4)
const SIG_LEN_FELTS = 17   # 65.div_ceil(4)

# PROCEDURES
# ================================================================================================

#! Verifies an secp256k1 ECDSA signature compatible with `miden-crypto::ecdsa_k256_keccak`.
#!
#! This wrapper mirrors the materialization performed in `miden-crypto::ecdsa_k256_keccak`: given
#! a public key commitment and the original message, it reconstructs the calldata expected by the
#! precompile (public key bytes, Keccak256(message), signature). The public key and signature are
#! supplied via the advice stack, and can be obtained with the `ecdsa_k256_keccak` function.
#!
#! Inputs:
#!   Operand stack: [PK_COMM, MSG, ...]
#!   Advice stack:  [PK[9] | SIG[17] | ...]
#! Outputs:
#!   Operand stack: []
#!   Advice stack:  []
#!
#! Where:
#! - `PK_COMM`: Poseidon2 hash commitment of the 32-byte ECDSA public key
#! - `MSG`: single word (4 field elements) representing the message to verify
#! - `PK[9]`: 33-byte public key packed as 9 field elements on advice stack
#! - `SIG[17]`: 65-byte signature packed as 17 field elements on advice stack
#!
#! Local memory layout (element addresses):
#!   - locaddr[0 ..9 ] : compressed public key (33 bytes packed as 9 felts)
#!   - locaddr[12..20] : message bytes (MSG written as eight u32 limbs)
#!   - locaddr[20..28] : keccak256(message) digest (8 felts)
#!   - locaddr[28..45] : signature (65 bytes packed as 17 felts)
#!
#! The procedure traps if:
#! - The public key does not hash to `PK_COMM` (invalid commitment)
#! - The signature verification fails
@locals(48)
pub proc verify
    # Load the compressed public key (9 felts) into local memory at locaddr.[0..9]
    padw adv_loadw loc_storew_le.0

    adv_loadw loc_storew_le.4 dropw
    adv_push.1 loc_store.8

    # Compute the expected commitment and ensure it matches the provided PK_COMM
    push.PK_LEN_FELTS locaddr.0 exec.poseidon2::hash_elements
    assert_eqw.err="invalid public key commitment"
    # => [MSG, ...]

    # Materialize the message bytes at locaddr.[12..20]
    locaddr.12 movdn.4 exec.word::store_word_u32s_le
    # [...]

    # Hash the 32-byte message with Keccak256
    push.32 locaddr.12 exec.keccak256::hash_bytes
    # => [DIGEST[0..8], ...]

    # Store the resulting digest at locaddr.[20..28]
    loc_storew_le.20 dropw
    loc_storew_le.24
    # => [DIGEST[4..8], ...]

    # store the signature (17 felts) provided via advice at locaddr.[28..45]
    adv_loadw loc_storew_le.28
    adv_loadw loc_storew_le.32
    adv_loadw loc_storew_le.36
    adv_loadw loc_storew_le.40 dropw
    adv_push.1 loc_store.44
    # => [...]

    # Invoke the deferred verification precompile with in-memory calldata
    locaddr.28
    locaddr.20
    locaddr.0
    # => [pk_ptr, digest_ptr, sig_ptr]
    exec.verify_prehash
    # => [result, ...]

    # Trap if verification failed
    assert.err="ECDSA signature verification failed"
end

#! Verifies an ECDSA signature with pre-hashed message using deferred execution.
#!
#! This procedure is intended for manual signature verification where the caller
#! has already computed the message digest.
#!
#! The caller provides the public key, the pre-hashed message digest, and the signature data in
#! memory. This routine forwards the request to the host precompile and returns the boolean result.
#! In typical flows the digest is obtained from `keccak256::hash_bytes`, but any 32-byte prehash
#! is accepted.
#!
#! Input:  `[pk_ptr, digest_ptr, sig_ptr, ...]`
#! Output: `[result, ...]`
#!
#! Where:
#! - `pk_ptr`: word-aligned memory address containing the 33-byte compressed secp256k1 public key
#! - `digest_ptr`: word-aligned memory address containing the 32-byte message digest
#! - `sig_ptr`: word-aligned memory address containing the 65-byte signature
#! - `result`: 1 if the signature is valid, 0 if invalid
#!
#! All data must be stored in memory as packed u32 values (little-endian), with unused bytes
#! in the final u32 set to zero.
pub proc verify_prehash
    exec.verify_prehash_impl
    # => [COMM, TAG, result, ...]

    # Log the precompile request for deferred verification
    exec.sys::log_precompile_request
    # => [result, ...]
end

# INTERNAL PROCEDURES
# ================================================================================================

#! Internal implementation of ECDSA signature verification via deferred computation.
#! This procedure is intended for manual signature verification where the caller
#! has already computed the message digest.
#!
#! Emits an event to trigger the precompile handler, reads the verification result from
#! the advice stack, and computes the commitment and tag for tracking deferred verification.
#!
#! This procedure mimics the `ecdsa_secp256k1::PublicKey::verify_prehash()` function from
#! `miden-crypto`, which takes a pre-hashed message that the caller must provide
#! (e.g. obtained using the keccak256 precompile).
#!
#! Input: `[pk_ptr, digest_ptr, sig_ptr, ...]`
#! Output: `[COMM, TAG, result, ...]`
#!
#! Where:
#! - `pk_ptr`: word-aligned memory address containing 33-byte public key
#! - `digest_ptr`: word-aligned memory address containing 32-byte digest
#! - `sig_ptr`: word-aligned memory address containing 65-byte signature
#! - `COMM`: commitment to calldata computed as
#!       `Poseidon2(Poseidon2(Poseidon2(pk) || Poseidon2(digest)) || Poseidon2(sig))`
#! - `TAG`: `[ECDSA_VERIFY_EVENT, result, 0, 0]`
#! - `result`: 1 if signature is valid, 0 if invalid
pub proc verify_prehash_impl
    emit.ECDSA_VERIFY_EVENT
    # => [pk_ptr, digest_ptr, sig_ptr, ...]

    # Read verification result from advice stack (provided by the host)
    adv_push.1
    # => [result, pk_ptr, digest_ptr, sig_ptr, ...]

    # Compute commitment: COMM = Poseidon2(Poseidon2(Poseidon2(pk) || Poseidon2(digest)) || Poseidon2(sig))
    # Compute COMM_PK = Poseidon2(pk)
    push.PK_LEN_FELTS movup.2 exec.poseidon2::hash_elements
    # => [COMM_PK, result, digest_ptr, sig_ptr]

    # Compute COMM_DIGEST = Poseidon2(digest_bytes)
    push.DIGEST_LEN_FELTS movup.6 exec.poseidon2::hash_elements
    # => [COMM_DIGEST, COMM_PK, result, sig_ptr]

    # Merge COMM_PK and COMM_DIGEST into COMM_PK_DIGEST = Poseidon2(Poseidon2(pk) || Poseidon2(digest))
    # hmerge([A, B]) computes merge(&[A, B]), so we need COMM_PK on top
    swapw
    # => [COMM_PK, COMM_DIGEST, result, sig_ptr]
    exec.poseidon2::merge
    # => [COMM_PK_DIGEST, result, sig_ptr]

    # Compute COMM_SIG = Poseidon2(sig_bytes)
    push.SIG_LEN_FELTS movup.6 exec.poseidon2::hash_elements
    # => [COMM_SIG, COMM_PK_DIGEST, result]

    # Merge into final commitment COMM = Poseidon2(COMM_PK_DIGEST || COMM_SIG)
    # hmerge([A, B]) computes merge(&[A, B]), so we need COMM_PK_DIGEST on top
    swapw
    # => [COMM_PK_DIGEST, COMM_SIG, result]
    exec.poseidon2::merge
    # => [COMM, result]

    # Create TAG = [ECDSA_VERIFY_EVENT, result, 0, 0] on stack
    # Stack positions 4-7 should have [event_id, result, 0, 0] for get_stack_word(4)
    push.0.0 dup.6 push.ECDSA_VERIFY_EVENT swapw
    # => [COMM, TAG, result]
end
