use miden::core::sys
use miden::core::crypto::hashes::rpo256

# ENCODING CONVENTIONS
# ================================================================================================
#
# This module uses the following notation for data representation:
# - VALUE_U32[n] = arrays of n u32 values, denoted as [v_0, ..., v_{n-1}]
# - VALUE_U8[n] = arrays of n u8 values, denoted as [b_0, ..., b_{n-1}]
# - Conversion: v_i = u32::from_le_bytes([b_{4i}, b_{4i+1}, b_{4i+2}, b_{4i+3}])
# - Fixed-size examples: DIGEST_U32[8] = [d_0, ..., d_7], INPUT_U8[32] = [b_0, ..., b_31]
# - DIGEST_U32[8] = [d_0, ..., d_7] = Keccak256(INPUT_U8[..])

# CONSTANTS
# ================================================================================================

const KECCAK_HASH_BYTES_EVENT = event("miden::core::hash::keccak256::hash_bytes")

# PROCEDURES
# ================================================================================================

#! Computes Keccak256 hash of data stored in memory.
#!
#! Input: [ptr, len_bytes, ...]
#! Output: [DIGEST_U32[8], ...]
#!
#! Where:
#! - ptr: word-aligned memory address containing INPUT_U32[len_u32] where len_u32=⌈len_bytes/4⌉
#! - len_bytes: number of bytes to hash
#! - INPUT_U32[len_u32] ~ INPUT_U8[len_bytes] with u32 packing (unused bytes in final u32 must be 0)
#! - DIGEST_U32[8] = [d_0, ..., d_7] = Keccak256(INPUT_U8[len_bytes])
pub proc hash_bytes
    exec.hash_bytes_impl
    # => [COMM, TAG, DIGEST_U32[8], ...]

    # Log the precompile request for deferred verification
    exec.sys::log_precompile_request
    # => [DIGEST_U32[8], ...]
end

#! Computes Keccak256 hash of a single 256-bit input.
#!
#! Input: [INPUT_U32[8], ...]
#! Output: [DIGEST_U32[8], ...]
#!
#! Where
#! - DIGEST_U32[8] = [d_0, ..., d_7] = Keccak256(INPUT_U8[32])
#! - INPUT_U32[8] = [i_0, ..., i_7] = [INPUT_LO, INPUT_HI] ~ INPUT_U8[32] with u32 packing
@locals(8)
pub proc hash
    # Store [INPUT_LO, INPUT_HI] in local memory
    loc_storew_le.0 dropw
    loc_storew_le.4 dropw

    push.32 locaddr.0
    # => [ptr, 32]

    exec.hash_bytes
end

#! Merges two 256-bit digests via Keccak256 hash.
#!
#! Input: [INPUT_L_U32[8], INPUT_R_U32[8], ...]
#! Output: [DIGEST_U32[8], ...]
#!
#! Where
#! - INPUT_L_U32[8] = [l_0, ..., l_7] = [INPUT_L_LO, INPUT_L_HI] ~ INPUT_L_U8[32]
#! - INPUT_R_U32[8] = [r_0, ..., r_7] = [INPUT_R_LO, INPUT_R_HI] ~ INPUT_R_U8[32]
#! - DIGEST_U32[8] = [d_0, ..., d_7] = Keccak256(INPUT_L_U8[32] || INPUT_R_U8[32])
@locals(16)
pub proc merge
    # Store [INPUT_L_LO, INPUT_L_HI, INPUT_R_LO, INPUT_R_HI] in local memory
    loc_storew_le.0 dropw
    loc_storew_le.4 dropw
    loc_storew_le.8 dropw
    loc_storew_le.12 dropw

    push.64 locaddr.0
    # => [ptr, 64]

    exec.hash_bytes
end

# INTERNAL PROCEDURES
# ================================================================================================

#! Internal implementation of memory-based Keccak256 computation via deferred computation.
#!
#! Emits an event to populate the advice stack with digest and store the preimage for deferred verification.
#! Returns the commitment to the precompile call and its tag.
#!
#! Input: [ptr, len_bytes, ...]
#! Output: [COMM, TAG, DIGEST_U32[8], ...]
#!
#! Where:
#! - ptr: word-aligned memory address containing INPUT_U32[len_u32] where len_u32=⌈len_bytes/4⌉
#! - len_bytes: number of bytes to hash
#! - COMM: the calldata commitment `Rpo256(Rpo256(INPUT_U32[..]) || Rpo256(DIGEST_U32[..]))` consumed by `log_precompile`
#! - TAG = [KECCAK_HASH_BYTES_EVENT, len_bytes, 0, 0] encodes the precompile identifier and the byte length as metadata
#! - DIGEST_U32[8] = [d_0, ..., d_7] = Keccak256(INPUT_U8[len_bytes])
@locals(8)
pub proc hash_bytes_impl
    emit.KECCAK_HASH_BYTES_EVENT
    # => [ptr, len_bytes, ...]

    # Compute len_u32 = ceil(len_bytes / 4)
    dup.1 add.3 u32shr.2 swap
    # => [ptr, len_u32, len_bytes, ...]

    # Load digest from advice stack (8 u32 limbs) and write to digest_ptr = locaddr.0
    # simultaneously compute COMM_DIGEST = Rpo(DIGEST[0..8])
    locaddr.0
    exec.rpo256::init_no_padding
    # => [R0, R1, C, digest_ptr, ptr, len_u32, len_bytes, ...]
    adv_pipe
    exec.rpo256::permute
    exec.rpo256::squeeze_digest
    # => [COMM_DIGEST, digest_ptr, ptr, len_u32, len_bytes, ...]

    movup.4 drop
    # => [COMM_DIGEST, ptr, len_u32, len_bytes, ...]

    # Compute COMM_INPUT = rpo::hash_elements(ptr, len_u32)
    movup.5 movup.5 exec.rpo256::hash_elements
    # => [COMM_INPUT, COMM_DIGEST, len_bytes, ...]

    # Compute COMM = hash(COMM_INPUT || COMM_DIGEST)
    exec.rpo256::merge
    # => [COMM, len_bytes, ...]

    # Prepare TAG = [KECCAK_HASH_BYTES_EVENT, len_bytes, 0, 0]
    push.0.0 movup.6 push.KECCAK_HASH_BYTES_EVENT swapw
    # => [COMM, TAG, ...]

    # Reload digest limbs from locals
    padw loc_loadw_le.4
    padw loc_loadw_le.0
    swapdw
    # => [COMM, TAG, DIGEST_U32[8], ...]
end
