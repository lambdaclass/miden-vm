use miden::core::mem
use miden::core::sys
use miden::core::word
use miden::core::crypto::hashes::poseidon2

# ENCODING CONVENTIONS
# ================================================================================================
#
# - Input bytes are stored in memory as packed u32 values in little-endian format
# - DIGEST_U32[16] = [d_0, ..., d_15] with d_i = u32::from_le_bytes([b_{4i}, ..., b_{4i+3}])
# - SHA512 digest is represented as 16 u32 limbs

# CONSTANTS
# ================================================================================================

const SHA512_HASH_BYTES_EVENT = event("miden::core::hash::sha512::hash_bytes")

# PROCEDURES
# ================================================================================================

#! Computes SHA512 hash of data stored in memory.
#!
#! Input:  [ptr, len_bytes, ...]
#! Output: [DIGEST_U32[16], ...]
pub proc hash_bytes
    exec.hash_bytes_impl
    # => [COMM, TAG, DIGEST_U32[16], ...]

    exec.sys::log_precompile_request
    # => [DIGEST_U32[16], ...]
end

# INTERNAL PROCEDURES
# ================================================================================================

#! Internal implementation of memory-based SHA512 computation via deferred computation.
#!
#! Emits an event to populate the advice stack with the digest and store the preimage for deferred
#! verification. Returns the commitment to the calldata and its tag.
#!
#! Input:  [ptr, len_bytes, ...]
#! Output: [COMM, TAG, DIGEST_U32[16], ...]
@locals(24)
pub proc hash_bytes_impl
    emit.SHA512_HASH_BYTES_EVENT
    # => [ptr, len_bytes, ...]

    # Compute len_u32 = ceil(len_bytes / 4)
    dup.1 add.3 u32shr.2 swap
    # => [ptr, len_u32, len_bytes, ...]

    # Load digest from advice stack (16 u32 limbs) and write to digest_ptr = locaddr.0
    # simultaneously compute COMM_DIGEST = Poseidon2(DIGEST[0..16])
    locaddr.0
    exec.poseidon2::init_no_padding
    # => [R0, R1, C, digest_ptr, ptr, len_u32, len_bytes, ...]
    repeat.2
        adv_pipe
        exec.poseidon2::permute
    end
    exec.poseidon2::squeeze_digest
    # => [COMM_DIGEST, digest_ptr, ptr, len_u32, len_bytes, ...]

    movup.4 drop
    # => [COMM_DIGEST, ptr, len_u32, len_bytes, ...]

    # Compute COMM_INPUT = poseidon2::hash_elements(ptr, len_u32)
    movup.5 movup.5 exec.poseidon2::hash_elements
    # => [COMM_INPUT, COMM_DIGEST, len_bytes, ...]

    # Compute COMM = hash(COMM_INPUT || COMM_DIGEST)
    exec.poseidon2::merge
    # => [COMM, len_bytes, ...]

    # Prepare TAG = [SHA512_HASH_BYTES_EVENT, len_bytes, 0, 0]
    push.0.0 movup.6 push.SHA512_HASH_BYTES_EVENT swapw
    # => [COMM, TAG, ...]

    # Reload digest limbs from locals
    padw loc_loadw_le.12 movdnw.2
    padw loc_loadw_le.8 movdnw.2
    padw loc_loadw_le.4 movdnw.2
    padw loc_loadw_le.0 movdnw.2
    # => [COMM, TAG, DIGEST_U32[16], ...]
end
