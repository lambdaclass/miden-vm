
## miden::core::crypto::dsa::ecdsa_k256_keccak
| Procedure | Description |
| ----------- | ------------- |
| verify | Verifies an secp256k1 ECDSA signature compatible with `miden-crypto::ecdsa_k256_keccak`.<br /><br />This wrapper mirrors the materialization performed in `miden-crypto::ecdsa_k256_keccak`: given<br />a public key commitment and the original message, it reconstructs the calldata expected by the<br />precompile (public key bytes, Keccak256(message), signature). The public key and signature are<br />supplied via the advice stack, and can be obtained with the `ecdsa_k256_keccak` function.<br /><br />Inputs:<br />Operand stack: [PK_COMM, MSG, ...]<br />Advice stack:  [PK[9] \| SIG[17] \| ...]<br />Outputs:<br />Operand stack: []<br />Advice stack:  []<br /><br />Where:<br />- `PK_COMM`: Poseidon2 hash commitment of the 32-byte ECDSA public key<br />- `MSG`: single word (4 field elements) representing the message to verify<br />- `PK[9]`: 33-byte public key packed as 9 field elements on advice stack<br />- `SIG[17]`: 65-byte signature packed as 17 field elements on advice stack<br /><br />Local memory layout (element addresses):<br />- locaddr[0 ..9 ] : compressed public key (33 bytes packed as 9 felts)<br />- locaddr[12..20] : message bytes (MSG written as eight u32 limbs)<br />- locaddr[20..28] : keccak256(message) digest (8 felts)<br />- locaddr[28..45] : signature (65 bytes packed as 17 felts)<br /><br />The procedure traps if:<br />- The public key does not hash to `PK_COMM` (invalid commitment)<br />- The signature verification fails<br /> |
| verify_prehash | Verifies an ECDSA signature with pre-hashed message using deferred execution.<br /><br />This procedure is intended for manual signature verification where the caller<br />has already computed the message digest.<br /><br />The caller provides the public key, the pre-hashed message digest, and the signature data in<br />memory. This routine forwards the request to the host precompile and returns the boolean result.<br />In typical flows the digest is obtained from `keccak256::hash_bytes`, but any 32-byte prehash<br />is accepted.<br /><br />Input:  `[pk_ptr, digest_ptr, sig_ptr, ...]`<br />Output: `[result, ...]`<br /><br />Where:<br />- `pk_ptr`: word-aligned memory address containing the 33-byte compressed secp256k1 public key<br />- `digest_ptr`: word-aligned memory address containing the 32-byte message digest<br />- `sig_ptr`: word-aligned memory address containing the 65-byte signature<br />- `result`: 1 if the signature is valid, 0 if invalid<br /><br />All data must be stored in memory as packed u32 values (little-endian), with unused bytes<br />in the final u32 set to zero.<br /> |
| verify_prehash_impl | Internal implementation of ECDSA signature verification via deferred computation.<br />This procedure is intended for manual signature verification where the caller<br />has already computed the message digest.<br /><br />Emits an event to trigger the precompile handler, reads the verification result from<br />the advice stack, and computes the commitment and tag for tracking deferred verification.<br /><br />This procedure mimics the `ecdsa_secp256k1::PublicKey::verify_prehash()` function from<br />`miden-crypto`, which takes a pre-hashed message that the caller must provide<br />(e.g. obtained using the keccak256 precompile).<br /><br />Input: `[pk_ptr, digest_ptr, sig_ptr, ...]`<br />Output: `[COMM, TAG, result, ...]`<br /><br />Where:<br />- `pk_ptr`: word-aligned memory address containing 33-byte public key<br />- `digest_ptr`: word-aligned memory address containing 32-byte digest<br />- `sig_ptr`: word-aligned memory address containing 65-byte signature<br />- `COMM`: commitment to calldata computed as<br />`Poseidon2(Poseidon2(Poseidon2(pk) \|\| Poseidon2(digest)) \|\| Poseidon2(sig))`<br />- `TAG`: `[ECDSA_VERIFY_EVENT, result, 0, 0]`<br />- `result`: 1 if signature is valid, 0 if invalid<br /> |
