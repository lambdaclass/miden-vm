
## miden::core::crypto::dsa::eddsa_ed25519
| Procedure | Description |
| ----------- | ------------- |
| verify | Verifies an Ed25519 EdDSA signature compatible with `miden-crypto::eddsa_25519_sha512`.<br /><br />This wrapper mirrors the materialization performed in `miden-crypto::eddsa_25519_sha512`: given<br />a public key commitment and the original message, it reconstructs the calldata expected by the<br />precompile (public key bytes, SHA512(R \|\| PK \|\| MSG), signature). The public key and signature<br />are supplied via the advice stack, and can be obtained with the `eddsa_sign` function.<br /><br />Inputs:<br />Operand stack: [PK_COMM, MSG, ...]<br />Advice stack:  [PK[8] \| SIG[16] \| ...]<br />Outputs:<br />Operand stack: []<br />Advice stack:  []<br /><br />Where:<br />- `PK_COMM`: RPO hash commitment of the 32-byte Ed25519 public key<br />- `MSG`: single word (4 field elements) representing the message to verify<br />- `PK[8]`: 32-byte public key packed as 8 field elements on advice stack<br />- `SIG[16]`: 64-byte signature packed as 16 field elements on advice stack<br /><br />Local memory layout (element addresses):<br />- locaddr[0..8]:   public key (32 bytes packed as 8 felts)<br />- locaddr[8..16]:  message (32 bytes = 8 felts)<br />- locaddr[16..32]: signature (64 bytes packed as 16 felts)<br />- locaddr[32..56]: SHA512 input buffer (R \|\| PK \|\| MSG = 96 bytes = 24 felts)<br />- locaddr[56..72]: k_digest = SHA512(R \|\| PK \|\| MSG) (64 bytes = 16 felts)<br /><br />The procedure traps if:<br />- The public key does not hash to `PK_COMM` (invalid commitment)<br />- The signature verification fails<br /> |
| verify_prehash | Verifies an EdDSA (Ed25519) signature with a pre-computed nonce digest.<br /><br />This procedure is intended for manual signature verification where the caller<br />has already computed the message digest.<br /><br />This procedure uses deferred verification via a precompile. The actual cryptographic<br />verification is performed by the host, and the result is provided via the advice stack.<br /><br />Input:  `[pk_ptr, digest_ptr, sig_ptr, ...]`<br />Output: `[result, ...]`<br /><br />Where:<br />- `pk_ptr`:  word-aligned memory address containing the 32-byte Ed25519 public key<br />- `digest_ptr`: word-aligned memory address containing the 64-byte challenge hash `k`<br />- `sig_ptr`: word-aligned memory address containing the 64-byte Ed25519 signature<br />- `result`:  1 if the signature is valid, 0 otherwise<br /><br />All data must be stored in memory as packed u32 field elements (little-endian), with unused limbs<br />in the final word set to zero.<br /> |
| verify_prehash_impl | Internal implementation of EdDSA verification via deferred computation.<br /><br />Emits an event to trigger the host precompile, reads the verification result from the<br />advice stack, and computes the commitment/tag pair used for deferred verification.<br /><br />Input:  `[pk_ptr, k_digest_ptr, sig_ptr, ...]`<br />Output: `[COMM, TAG, result, ...]`<br /><br />Where:<br />- `COMM`: `Rpo256(Rpo256(Rpo256(pk) \|\| Rpo256(k_digest)) \|\| Rpo256(sig))`<br />- `TAG`:  `[EDDSA_VERIFY_EVENT, result, 0, 0]`<br />- `result`: host verification result (1 or 0)<br /> |
