
## miden::core::math::u64
| Procedure | Description |
| ----------- | ------------- |
| overflowing_add | Performs addition of two unsigned 64 bit integers preserving the overflow.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [overflow, c_lo, c_hi, ...], where c = (a + b) % 2^64<br />This takes 5 cycles.<br /> |
| wrapping_add | Performs addition of two unsigned 64 bit integers discarding the overflow.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = (a + b) % 2^64<br />This takes 6 cycles.<br /> |
| wrapping_sub | Performs subtraction of two unsigned 64 bit integers discarding the overflow.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = (a - b) % 2^64<br />This takes 11 cycles.<br /> |
| overflowing_sub | Performs subtraction of two unsigned 64 bit integers preserving the overflow.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [underflow, c_lo, c_hi, ...], where c = (a - b) % 2^64<br />This takes 15 cycles.<br /> |
| wrapping_mul | Performs multiplication of two unsigned 64 bit integers discarding the overflow.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = (a * b) % 2^64<br />This takes 15 cycles.<br /> |
| widening_mul | Performs multiplication of two unsigned 64 bit integers preserving the overflow.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c_lo, c_mid_lo, c_mid_hi, c_hi, ...], where<br />c = a * b is represented as a 128-bit value split into 4 32-bit limbs.<br />This takes 22 cycles.<br /> |
| lt | Performs less-than comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c, ...], where c = 1 when a < b, and 0 otherwise.<br />This takes 12 cycles.<br /> |
| gt | Performs greater-than comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c, ...], where c = 1 when a > b, and 0 otherwise.<br />This takes 13 cycles.<br /> |
| lte | Performs less-than-or-equal comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c, ...], where c = 1 when a <= b, and 0 otherwise.<br />This takes 14 cycles.<br /> |
| gte | Performs greater-than-or-equal comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c, ...], where c = 1 when a >= b, and 0 otherwise.<br />This takes 13 cycles.<br /> |
| eq | Performs equality comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c, ...], where c = 1 when a == b, and 0 otherwise.<br />This takes 5 cycles.<br /> |
| neq | Performs inequality comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c, ...], where c = 1 when a != b, and 0 otherwise.<br />This takes 5 cycles.<br /> |
| eqz | Performs comparison to zero of an unsigned 64 bit integer.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, ...] -> [c, ...], where c = 1 when a == 0, and 0 otherwise.<br />This takes 4 cycles.<br /> |
| min | Compares two unsigned 64 bit integers and drops the larger one from the stack.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = min(a, b).<br />This takes 23 cycles.<br /> |
| max | Compares two unsigned 64 bit integers and drops the smaller one from the stack.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = max(a, b).<br />This takes 24 cycles.<br /> |
| div | Performs division of two unsigned 64 bit integers discarding the remainder.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = a // b<br />This takes 54 cycles.<br /> |
| mod | Performs modulo operation of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = a % b<br />This takes 56 cycles.<br /> |
| divmod | Performs divmod operation of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [q_lo, q_hi, r_lo, r_hi, ...], where q = a / b, r = a % b.<br />This takes 56 cycles.<br /> |
| and | Performs bitwise AND of two unsigned 64-bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = a AND b.<br />This takes 5 cycles.<br /> |
| or | Performs bitwise OR of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = a OR b.<br />This takes 5 cycles.<br /> |
| xor | Performs bitwise XOR of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_lo, b_hi, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = a XOR b.<br />This takes 5 cycles.<br /> |
| shl | Performs left shift of one unsigned 64-bit integer.<br />The input value to be shifted is assumed to be represented using 32 bit limbs, but this is not checked.<br />The shift value n should be in the range [0, 64), otherwise it will result in an error.<br />Stack transition looks as follows:<br />[n, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = (a << n) mod 2^64.<br />This takes 21 cycles.<br /> |
| shr | Performs right shift of one unsigned 64-bit integer.<br />The input value to be shifted is assumed to be represented using 32 bit limbs, but this is not checked.<br />The shift value n should be in the range [0, 64), otherwise it will result in an error.<br />Stack transition looks as follows:<br />[n, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = a >> n.<br />This takes 44 cycles.<br /> |
| rotl | Performs left rotation of one unsigned 64-bit integer.<br />The input value to be rotated is assumed to be represented using 32 bit limbs, but this is not checked.<br />The rotation amount n should be in the range [0, 64), otherwise it will result in an error.<br />Stack transition looks as follows:<br />[n, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = a <<< n (rotate left).<br />This takes 35 cycles.<br /> |
| rotr | Performs right rotation of one unsigned 64-bit integer.<br />The input value to be rotated is assumed to be represented using 32 bit limbs, but this is not checked.<br />The rotation amount n should be in the range [0, 64), otherwise it will result in an error.<br />Stack transition looks as follows:<br />[n, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = a >>> n (rotate right).<br />This takes 44 cycles.<br /> |
| clz | Counts the number of leading zeros of one unsigned 64-bit integer.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_lo, n_hi, ...] -> [clz, ...], where clz is the number of leading zeros of value n.<br />This takes 48 cycles.<br /> |
| ctz | Counts the number of trailing zeros of one unsigned 64-bit integer.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_lo, n_hi, ...] -> [ctz, ...], where ctz is the number of trailing zeros of value n.<br />This takes 41 cycles.<br /> |
| clo | Counts the number of leading ones of one unsigned 64-bit integer.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_lo, n_hi, ...] -> [clo, ...], where clo is the number of leading ones of value n.<br />This takes 47 cycles.<br /> |
| cto | Counts the number of trailing ones of one unsigned 64-bit integer.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_lo, n_hi, ...] -> [cto, ...], where cto is the number of trailing ones of value n.<br />This takes 40 cycles.<br /> |
