
## miden::core::word
| Procedure | Description |
| ----------- | ------------- |
| reverse | Reverses order of the first four elements on the stack<br /><br />Note: This functionality is also available as the `reversew` instruction<br /><br />Inputs:  [a, b, c, d, ...]<br />Outputs: [d, c, b, a, ...]<br /><br />Cycles: 3<br /> |
| store_word_u32s_le | Writes the components of a word to memory as eight u32 limbs in little-endian order.<br /><br />Inputs:  [w0, w1, w2, w3, out_ptr, ...]<br />Outputs: [...]<br /><br />Where:<br />- `w*` are the felts of the input word. Each felt is split into a low and high 32-bit limb.<br />- `out_ptr` is an element address in memory.<br />- Memory layout after the call: `[w0_lo, w0_hi, w1_lo, w1_hi, w2_lo, w2_hi, w3_lo, w3_hi]`.<br /><br />Cycles: 8 * (split + store pair) ~= 176<br /> |
| eqz | Returns a boolean indicating whether the input word is [0, 0, 0, 0].<br /><br />Inputs:  [INPUT_WORD]<br />Outputs: [is_empty_word]<br /><br />Where:<br />- INPUT_WORD is the word to compare against [0, 0, 0, 0].<br />- is_empty_word is a boolean indicating whether INPUT_WORD is all zeros.<br /><br />Cycles: 10<br /> |
| testz | Returns a boolean indicating whether the input word is [0, 0, 0, 0]. Unlike eqz, this does not<br />consume the inputs.<br /><br />Inputs:  [INPUT_WORD]<br />Outputs: [is_empty_word, INPUT_WORD]<br /><br />Where:<br />- INPUT_WORD is the word to compare against [0, 0, 0, 0].<br />- is_empty_word is a boolean indicating whether INPUT_WORD is all zeros.<br /><br />Cycles: 11<br /> |
| gt | Returns true if LHS is strictly greater than RHS, false otherwise.<br /><br />This compares words using the same ordering as Merkle tree key comparisons.<br /><br />The implementation avoids branching for performance reasons.<br /><br />For reference, this is equivalent to the following Rust function:<br /><br />fn is_word_greater(word1: Word, word2: Word) -> bool {<br />let mut result = false;<br />let mut cont = true;<br /><br />for i in (0..4).rev() {<br />let gt = word1[i].as_canonical_u64() > word2[i].as_canonical_u64();<br />let eq = word1[i].as_canonical_u64() == word2[i].as_canonical_u64();<br />result \|= gt & cont;<br />cont &= eq;<br />}<br /><br />result<br />}<br /><br />Inputs:  [RHS, LHS]<br />Outputs: [is_lhs_greater]<br /><br />Cycles: 117<br /> |
| gte | Returns true if LHS is greater than or equal to RHS.<br /><br />Inputs:  [RHS, LHS]<br />Outputs: [is_lhs_greater_or_equal]<br /><br />Cycles: 118<br /> |
| lt | Returns true if LHS is strictly less than RHS, false otherwise.<br /><br />The implementation avoids branching for performance reasons.<br /><br />From an implementation standpoint this is exactly the same as `word::gt` except it uses<br />`lt` rather than `gt`. See its docs for details.<br /><br />Inputs:  [RHS, LHS]<br />Outputs: [is_lhs_lesser]<br /><br />Cycles: 117<br /> |
| lte | Returns true if LHS is less than or equal to RHS, false otherwise.<br /><br />Inputs:  [RHS, LHS]<br />Outputs: [is_lhs_less_or_equal]<br /><br />Cycles: 118<br /> |
| eq | Returns true if LHS is exactly equal to RHS, false otherwise.<br /><br />The implementation does not branch, and always performs the same number of comparisons.<br /><br />This is currently equivalent to the eqw instruction.<br /><br />Inputs:  [RHS, LHS]<br />Outputs: [lhs_eq_rhs]<br /><br />Cycles: 13<br /> |
| test_eq | Returns true if LHS is exactly equal to RHS, false otherwise. Preserves stack inputs.<br /><br />Like word::eq, the implementation does not branch, and always performs the same number<br />of comparisons.<br /><br />Inputs:  [RHS, LHS]<br />Outputs: [lhs_eq_rhs, RHS, LHS]<br /><br />Cycles: 15<br /> |
